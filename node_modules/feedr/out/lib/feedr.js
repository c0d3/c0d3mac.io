// Generated by CoffeeScript 1.6.3
(function() {
  var Feedr, TaskGroup, eachr, extendr, pathUtil, request, safefs, safeps, typeChecker,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty;

  extendr = require('extendr');

  eachr = require('eachr');

  TaskGroup = require('taskgroup').TaskGroup;

  typeChecker = require('typechecker');

  safefs = require('safefs');

  safeps = require('safeps');

  pathUtil = require('path');

  request = require('request');

  Feedr = (function() {
    Feedr.prototype.config = {
      log: null,
      cache: true,
      tmpPath: null,
      requestOptions: null,
      xml2jsOptions: null
    };

    function Feedr(config) {
      this.config = extendr.deepExtend({}, this.config, config);
      this;
    }

    Feedr.prototype.log = function() {
      var args, _base;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (typeof (_base = this.config).log === "function") {
        _base.log.apply(_base, args);
      }
      return this;
    };

    Feedr.prototype.readFeeds = function(feeds, next) {
      var failures, feedr, isArray, result, tasks;
      feedr = this;
      failures = 0;
      isArray = typeChecker.isArray(feeds);
      result = isArray ? [] : {};
      tasks = new TaskGroup().setConfig({
        concurrency: 0
      }).once('complete', function(err) {
        feedr.log((failures ? 'warn' : 'debug'), 'Feedr finished fetching', (failures ? "with " + failures + " failures" : ''));
        return next(err, result);
      });
      eachr(feeds, function(feedDetails, feedName) {
        return tasks.addTask(function(complete) {
          if (typeChecker.isString(feedDetails)) {
            feedDetails = {
              url: feedDetails
            };
          }
          if (feedDetails.name == null) {
            feedDetails.name = feedName;
          }
          return feedr.readFeed(feedDetails, function(err, data) {
            if (err) {
              feedr.log('debug', "Feedr failed to fetch [" + feedDetails.url + "] to [" + feedDetails.path + "]");
              feedr.log('err', err);
              ++failures;
            } else {
              if (isArray) {
                result.push(data);
              } else {
                result[feedName] = data;
              }
            }
            return complete();
          });
        });
      });
      if (feedr.config.tmpPath) {
        tasks.run();
      } else {
        safeps.getTmpPath(function(err, tmpPath) {
          if (err) {
            return next(err);
          }
          feedr.config.tmpPath = tmpPath;
          return tasks.run();
        });
      }
      return this;
    };

    Feedr.prototype.readFeed = function(feedDetails, next) {
      var cleanData, extname, feedr, parseFile, readFile, requestOptions, useCache, viaCache, viaRequest, writeFeed, xml2jsOptions, _ref;
      feedr = this;
      if (!feedr.config.tmpPath) {
        safeps.getTmpPath(function(err, tmpPath) {
          if (err) {
            return next(err);
          }
          feedr.config.tmpPath = tmpPath;
          return feedr.readFeed(feedDetails, next);
        });
        return this;
      }
      if (feedDetails == null) {
        feedDetails = {};
      }
      if (typeChecker.isString(feedDetails)) {
        feedDetails = {
          url: feedDetails,
          name: feedDetails
        };
      }
      if (!feedDetails.url) {
        return next(new Error('feed url was not supplied'), null, null);
      }
      if (feedDetails.hash == null) {
        feedDetails.hash = require('crypto').createHash('md5').update("feedr-" + JSON.stringify(feedDetails.url)).digest('hex');
      }
      if (feedDetails.path == null) {
        feedDetails.path = pathUtil.join(feedr.config.tmpPath, feedDetails.hash);
      }
      if (feedDetails.metaPath == null) {
        feedDetails.metaPath = feedDetails.path + '-meta.json';
      }
      if (feedDetails.name == null) {
        feedDetails.name = feedDetails.hash;
      }
      if (feedDetails.cache == null) {
        feedDetails.cache = feedr.config.cache;
      }
      useCache = feedDetails.cache;
      if (feedDetails.parse == null) {
        feedDetails.parse = true;
      }
      extname = pathUtil.extname(feedDetails.url.replace(/[?#].*/, ''));
      if (feedDetails.parse === true) {
        feedDetails.parse = extname === '.xml' || extname === '.atom' || extname === '.rss' || extname === '.rdf' || extname === '.html' || extname === '.html' ? 'xml' : extname === '.json' || extname === '.jsonp' || extname === '.js' ? 'json' : extname === '.coffee' || extname === '.cson' ? 'cson' : extname === '.yml' || extname === '.yaml' ? 'yaml' : false;
      }
      if (feedDetails.parse && ((_ref = feedDetails.parse) !== 'xml' && _ref !== 'json' && _ref !== 'yaml')) {
        return next(new Error("unrecognised parse value: " + feedDetails.parse), null, null);
      }
      requestOptions = extendr.deepExtend({
        url: feedDetails.url,
        timeout: 1 * 60 * 1000
      }, feedr.config.requestOptions || {}, feedDetails.requestOptions || {});
      xml2jsOptions = extendr.deepExtend({}, feedr.config.xml2jsOptions || {}, feedDetails.xml2jsOptions || {});
      if (feedDetails.checkResponse == null) {
        feedDetails.checkResponse = function(response, data, complete) {
          var err;
          if (feedDetails.url.indexOf('github.com') !== -1 && (data != null ? data.message : void 0)) {
            err = new Error(data.message);
          } else {
            err = null;
          }
          return complete(err);
        };
      }
      cleanData = function(data) {
        var key, keys, value;
        keys = [];
        for (key in data) {
          if (!__hasProp.call(data, key)) continue;
          value = data[key];
          if (typeChecker.isPlainObject(data)) {
            data[key] = cleanData(value);
          }
          keys.push(key);
        }
        if (keys.length === 1 && keys[0] === '_content') {
          data = data._content;
        }
        return data;
      };
      readFile = function(path, complete) {
        feedr.log('debug', "Feedr is reading [" + feedDetails.url + "] on [" + path + "]");
        return safefs.exists(path, function(exists) {
          if (!exists) {
            return complete(null, null);
          }
          return safefs.readFile(path, function(err, rawData) {
            if (err) {
              return complete(err, null);
            }
            return complete(null, rawData);
          });
        });
      };
      parseFile = function(path, complete) {
        feedr.log('debug', "Feedr is parsing [" + feedDetails.url + "] on [" + path + "]");
        return readFile(path, function(err, rawData) {
          var data;
          if (err || !rawData) {
            return complete(err, null);
          }
          try {
            data = JSON.parse(rawData.toString());
          } catch (_error) {
            err = _error;
            return complete(err, null);
          }
          return complete(null, data);
        });
      };
      writeFeed = function(response, data, complete) {
        var writeTasks;
        feedr.log('debug', "Feedr is writing [" + feedDetails.url + "] to [" + feedDetails.path + "]");
        writeTasks = new TaskGroup().setConfig({
          concurrency: 0
        }).once('complete', function(err) {
          return complete(err, data);
        });
        writeTasks.addTask(function(complete) {
          return safefs.writeFile(feedDetails.metaPath, JSON.stringify(response.headers), complete);
        });
        writeTasks.addTask(function(complete) {
          var rawData;
          if (feedDetails.parse) {
            rawData = JSON.stringify(data);
          } else {
            rawData = data;
          }
          return safefs.writeFile(feedDetails.path, rawData, complete);
        });
        return writeTasks.run();
      };
      viaCache = function(next) {
        var data, meta, readTasks;
        feedr.log('debug', "Feedr is remembering [" + feedDetails.url + "] from cache");
        meta = null;
        data = null;
        readTasks = new TaskGroup().setConfig({
          concurrency: 0
        }).once('complete', function(err) {
          return next(err, data, meta);
        });
        readTasks.addTask(function(complete) {
          return parseFile(feedDetails.metaPath, function(err, result) {
            if (err || !result) {
              return complete(err);
            }
            meta = result;
            return complete();
          });
        });
        readTasks.addTask(function(complete) {
          return readFile(feedDetails.path, function(err, rawData) {
            if (err || !rawData) {
              return complete(err);
            }
            if (feedDetails.parse) {
              try {
                data = JSON.parse(rawData.toString());
              } catch (_error) {
                err = _error;
                return complete(err);
              }
            } else {
              data = rawData;
            }
            return complete();
          });
        });
        return readTasks.run();
      };
      viaRequest = function(next) {
        var _base, _ref1;
        feedr.log('debug', "Feedr is fetching [" + feedDetails.url + "] to [" + feedDetails.path + "]");
        if (useCache && ((_ref1 = feedDetails.metaData) != null ? _ref1.etag : void 0)) {
          if (requestOptions.headers == null) {
            requestOptions.headers = {};
          }
          if ((_base = requestOptions.headers)['If-None-Match'] == null) {
            _base['If-None-Match'] = feedDetails.metaData.etag;
          }
        }
        return request(requestOptions, function(err, response, data) {
          var handleError, handleSuccess, parser, xml2js;
          handleError = function(err) {
            if (useCache) {
              return viaCache(next);
            }
            return next(err, data, requestOptions.headers);
          };
          handleSuccess = function(data) {
            return feedDetails.checkResponse(response, data, function(err) {
              if (err) {
                return handleError(err);
              }
              return writeFeed(response, data, function(err) {
                return next(err, data, requestOptions.headers);
              });
            });
          };
          if (err) {
            return handleError(err);
          }
          if (useCache && response.statusCode === 304) {
            return viaCache(next);
          }
          switch (feedDetails.parse) {
            case 'xml':
              xml2js = require('xml2js');
              parser = new xml2js.Parser(xml2jsOptions);
              parser.on('end', function(data) {
                return handleSuccess(data);
              });
              try {
                return parser.parseString(data.toString().trim());
              } catch (_error) {
                err = _error;
                if (err) {
                  return handleError(err);
                }
              }
              break;
            case 'cson':
              return require('CSON').parse(data.toString(), function(err, data) {
                if (err) {
                  return handleError(err);
                }
                return handleSuccess(data);
              });
            case 'json':
              data = data.toString().trim().replace(/(^([\s\;]|\/\*\*\/)+|[\s\;]+$)/g, '');
              data = data.replace(/^[a-z0-9]+/gi, '').replace(/^\(|\)$/g, '');
              try {
                data = JSON.parse(data);
              } catch (_error) {
                err = _error;
                data = data.replace(/\\'/g, "'");
                try {
                  data = JSON.parse(data);
                } catch (_error) {
                  err = _error;
                  if (err) {
                    return handleError(err);
                  }
                }
              }
              if (feedDetails.clean) {
                feedr.log('debug', "Feedr is cleaning data from [" + feedDetails.url + "]");
                data = cleanData(data);
              }
              return handleSuccess(data);
            case 'yaml':
              try {
                data = require('yamljs').parse(data.toString().trim());
              } catch (_error) {
                err = _error;
                if (err) {
                  return handleError(err);
                }
              }
              return handleSuccess(data);
            default:
              return handleSuccess(data);
          }
        });
      };
      if (useCache === false) {
        return viaRequest(next);
      }
      parseFile(feedDetails.metaPath, function(err, metaData) {
        if (err || !metaData) {
          return viaRequest(next);
        }
        feedDetails.metaData = metaData;
        if (metaData.expires && (new Date() < new Date(metaData.expires))) {
          return viaCache(next);
        }
        return viaRequest(next);
      });
      return this;
    };

    return Feedr;

  })();

  module.exports = {
    Feedr: Feedr,
    create: function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      return (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args);
        return Object(result) === result ? result : child;
      })(Feedr, args, function(){});
    }
  };

}).call(this);
